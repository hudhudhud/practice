<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>test</title>
  </head>
  <body>
    <div id="app">hello</div>
    <!--defer 这个属性的用途是表明脚本在执行时不会影响页
        面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<script>元素中设置
        defer 属性，相当于告诉浏览器立即下载，但延迟执行,将延迟
        到浏览器遇到</html>标签后再执行 -->
    <script src='a.js' defer></script>
    <!-- 指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。
        为此，建议异步脚本不要在加载期间修改 DOM。
        异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之
        后执行。 -->
    <script src='b.js' ></script>
    <script>
        
    </script>
  </body>
</html>

<!-- 
typeof null 
"object"

//基本数据类型包括 Undefined、 Null、 Boolean、 Number 和 String。

null==undefined 
true

NaN==NaN
false

isNaN(NaN) //内部参数不能转换为数字则为true
true

011 //八进制
9

0xf //16进制
15

Number(0xf) //如果字符串是十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
15

Number('22xx')
NaN

parseInt('22xx')  //parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字
22                  符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()
                    就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回 0）。
                    
                    如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了
                    一个非数字字符。

parseInt('0xf')  //不指定基数意味着让 parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。
15

parseInt('0xf',10)
0

parseFloat('0.123.443') //字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略
0.123

parseFloat("0908.5"); //它始终都会忽略前导的零
908.5

parseFloat('0x123.33') //十六进制格式的字符串则始终会被转换成 0
0

parseFloat("3.125e7") //如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后
31250000                都是零）， parseFloat()会返回整数

(10).toString(2) //数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字
1010              符串的一个副本）都有 toString()方法。通过传递基数， toString()可以输出以二进制、八进制、十六进制

null.toString()  //但 null 和 undefined 值没有这个方法
Cannot read property 'toString' of null

String(null)  //够将任何类型的值转换为字符串,不至于报错
'null'

//在对非数值应用一元加操作符时，该操作符会像 Number()转型函数一样对这个值执行转换
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
    return -1;
  }
};
s1 = +s1; // 值变成数值 1
s2 = +s2; // 值变成数值 1.1
s3 = +s3; // 值变成 NaN
b = +b; // 值变成数值 0
f = +f; // 值未变，仍然是 1.1
o = +o; // 值变成数值-1

==  相等和不相等——先转换再比较 
=== 全等和不全等——仅比较而不转换
var result1 = ("55" == 55); //true，因为转换后相等
var result2 = ("55" === 55); //false，因为不同的数据类型不相等
null == undefined  //true
null === undefined //false

//逗号操作符，在用于赋值时，逗号操作符总会返回表达式中的最后一项
var num = (5, 1, 4, 8, 0); // num 的值为 0

//label语句
 var num = 0;
  outPoint:
  for (var i = 0 ; i < 5 ; i++){
    for (var j = 0 ; j < 5 ; j++){
        if( i == 2 && j == 2 ){
          break outPoint; //跳出双层循环
        }
      num++;
    }
  }
  console.log(num); //12

  //switch
    如果省略 break 关键字，
    就会导致执行完当前 case 后，继续执行下一个 case。最后的 default 关键字则用于在表达式不匹配前
    面任何一种情形的时候，执行机动代码（因此，也相当于一个 else 语句）。

    从根本上讲， switch 语句就是为了让开发人员免于编写像下面这样的代码：
    if (i == 25){
      alert("25");
    } else if (i == 35) {
      alert("35");
    } else if (i == 45) {
      alert("45");
    } else {
      alert("Other");

    }
    而与此等价的 switch 语句如下所示：
    switch (i) {
      case 25:
        alert("25");
        break;
      case 35:
        alert("35");
        break;
      case 45:
        alert("45");
        break;
      default:
        alert("Other");
    }

//arguments
因为 arguments
对象中的值会自动反映到对应的命名参数，所以修改 arguments[0]，也就修改了 m，结果它们的
值都会变成 2。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但
它们的值会同步。严格模式下则不同步
    function a(m,n){
      arguments[0]=2
      console.log(m,n)
    }
    a(1,2) // 2 2
    
    "use strict"
    function a(m,n){
      arguments[0]=2
      console.log(m,n)
    }
    a(1,2) // 1 2


//访问变量有按值和按引用两种方式，而参数只能按值传递。
为了证明对象是按值传递的，我们再看一看下面这个经过修改的例子：
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); //"Nicholas"
这个例子与前一个例子的唯一区别，就是在 setName()函数中添加了两行代码：一行代码为 obj
重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的 name 属性。在把 person 传递给
setName()后，其 name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量 obj，同时将其 name
属性设置为"Greg"。如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性值
为"Greg"的新对象。但是，当接下来再访问 person.name 时，显示的值仍然是"Nicholas"。这说明
即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这
个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。


//类型检测
typeof 1  //基本类型
person instanceof Object  //引用类型

//在 Web 浏览器中，全局执行环境被认为是 window 对象，因
此所有全局变量和函数都是作为 window 对象的属性和方法创建的。

某个执行环境中的所有代码执行完毕后，该环境被销毁，
保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退
出——例如关闭网页或浏览器——时才会被销毁）。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。
而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境


每个环境都可以向上搜索作用域链，以查询变量和函数名；
但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

JavaScript 没有块级作用域，即
if (true) {
  var color = "blue";
}
alert(color); //"blue"
其他语言都只能在if块内部才能访问到color

如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什
么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到
了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味
着该变量尚未声明。


垃圾回收：
  标记回收（mark-and-sweep）：
    当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变
    量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
    垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
    然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记
    的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器
    完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
  引用计数（reference counting）：（有循环引用问题）
    跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。
    如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取
    得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这
    个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那
    些引用次数为零的值所占用的内存。

优化内存占用的最佳方式，就是为执行
中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个
做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在
它们离开执行环境时自动被解除引用，
函数中的局部变量在函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。

解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离
执行环境，以便垃圾收集器下次运行时将其回收。

离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然
后再回收其内存。


数组的 length 属性很有特点——它不是只读的
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 2;
alert(colors[2]); //undefined
 -->